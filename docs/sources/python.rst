====================
python学习笔记
====================

.. contents::

Learning Python
===============

变量的通用说明
------------

- 变量类型
	- 在某一时刻，python中的变量只是对一个对象的引用，变量本身的类型是可以
	  随时改变的，即引用一个不同类型的对象。

	- 类型是与对象相关联的，而不是变量。

	- 每个对象有2个重要的头部信息：类型和引用计数器。


- 共享引用和原地修改

	>>> L1 = [2, 3, 4]
	>>> L2 = L1
	>>> L3 = L1[:]
	>>> L1[0] = 5
	>>> L1
	[5, 3, 4]
	>>> L2
	[5, 3, 4]
	>>> L3
	[2, 3, 4]

	L1和L2引用同一对象，而L3则是L1的复制。

	在标准库中的copy模块有复制任一对象的功能。

- 两种相等比较

	is 和 ==

	如果2个变量引用同一对象的话则是is，如果仅仅是这2个变量的值相等，但是不
	引用同一对象，那么它们只是==而不是is。

        ::

            >>> a = 'xy'
            >>> b = 'xy'
            >>> a == b, a is b
            (True, True)
            >>> c = 'x y'
            >>> d = 'x y'
            >>> c == d, c is d
            (True, False)
            >>>     


	这是因为在内部，'xy'被缓存了，而'x y'则没有。      

	另外，sys模块的getrefcount会返回一个对象被引用的次数。

        ::

            >>> import sys
            >>> sys.getrefcount(1)
            353
            >>> sys.getrefcount('a')
            11

- 真与假
	+ 空的对象被认为是False，非空对象被认为是真。 ::

    	abc



    + 特殊对象None总被认为是假。


数字
--------------------

- repr,str和print

	默认的打印方式(即不使用print)内部是使用repr，如果使用print打印的话
	则是使用str。

	::

		>>> num = 1 / 3.0
		>>> num
		0.3333333333333333
		>>> repr(num)
		'0.3333333333333333'
		>>> str(num)
		'0.333333333333'
		>>> print(num)
		0.333333333333

- 数字和字符串之间的相互转换

	- oct,hex将数字转换为相应进制的字符串

	- str将数字按十进制转换为相应进制的字符串

	- int()将字符串按照指定格式转换为数字，

	- eval计算表达式(是一个字符串)，相当于将字符串转换为数字

	- 格式化表达式"%"可以将数字转换为字符串

	::

		>>> oct(19),hex(255)
		('023', '0xff')
		>>> str(123)
		'123'
		>>> int('0100'),int('023',8),int('0xff',16)
		(100, 19, 255)
		>>> eval('100'),eval('0100'),eval('0x40')
		(100, 64, 64)
		>>> "%o %x %X" % (64,255,255)
		'100 ff FF'

- 浮点数运算时会出现精度问题，可以使用小数模块代替Decimal

- 布尔类型

	True,False。实际上是int类型的一个子集，不过重载了repr和print方法，
	打印时显示为True和False


字符串
--------------------

- python中没有单个的字符类型，只有字符串类型。

- python中的单引号和双引号可以互换，即使字符串中包含有转义字符。

	::

		>>> print("a\nb\tc")
		a
		b	c
		>>> print('a\nb\tc')
		a
		b	c

- python中的三重引号并不会禁止其内部的转义字符

	::

		>>> x = """abc
		... def
		... xxx\n\n
		... yyy
		... """
		>>> print(x)
		abc
		def
		xxx


		yyy

		>>>

- 转义:
	'\ooo'  八进制表示
	'\xhh'  十六进制表示

- 可以用r('...')来禁止转义

- unicode字符
	+ 长度

		::

			>>> len('中国')
			6
			>>> len(u'中国')
			2
			>>>

	+ 和普通字符串的转换

		::

			>>> str(u'abc')
			'abc'
			>>> unicode('abc')
			u'abc'
			>>>

- 索引和切片

	::

		>>> s = 'abcdef'
		>>> s[1:3]
		'bc'
		>>> s[-1]
		'f'
		>>> s[::2]
		'ace'
		>>> s[5:1:-1]
		'fedc'
		>>>

- 字符的代码转换

	::

		>>> ord('s')
		115
		>>> chr(115)
		's'
		>>>

- 基于字典的字符串格式化

	使用'%(key)t'这种格式，其中的"key"是dict的键，其中的't'表示格式化所
	用的格式

	另外，vars()函数会返回本函数调用时所有的变量和它的值组成的一个dict，
	可以和格式化字符串联合起来使用这个技巧

	>>> d = {'name': 'bob', 'age': 16}
	>>> "My name is %(name)s, my age is %(age)d" % d
	'My name is bob, my age is 16'
	>>>
	>>> food = 'bread'
	>>> drink = 'milk'
	>>> vars()
	{'d': {'age': 16, 'name': 'bob'}, '__builtins__': <module '__builtin__' (built-in)>, 'drink': 'milk', '__package__': None, 'food': 'bread', 's': 'abcdef', 'x': 'abc\ndef\nxxx\n\n\nyyy\n', '__name__': '__main__', '__doc__': None}
	>>> "%(food)s %(drink)s" % vars()
	'bread milk'
	>>>

字典
----

- 构造字典的其它技术

	1.
		>>> dict(name='bob', age=18)
		{'age': 18, 'name': 'bob'}
	#.
		>>> dict([('name', 'bob'), ('age', 18)])
		{'age': 18, 'name': 'bob'}

		这种方法经常和zip()一起连用
	#.
		>>> dict.fromkeys(['a', 'b', 'c'], 0)
		{'a': 0, 'c': 0, 'b': 0}
		>>>

- 字典的一些方法

	d.keys(), d.values(), d.items()

- 字典的键并不一定总是字符串，也可以是数字等

元组
----

- 只有一个元素的元组

	::

		>>> a = (30)
		>>> a
		30
		>>> b = (40,)
		>>> b
		(40,)
		>>>

	与只有一个元素的列表相比较

	::

		>>> x = [1]
		>>> x
		[1]
		>>> y = [2, ]
		>>> y
		[2]

- 元组的圆括号有时可以省略，但最好不省略以增强可读性

- 元组的不可变性是指元组本身及其顶层内容，而不是元组中嵌套的值

	::

		>>> x = (1, ['a', 'b'], 3)
		>>> x[1] = '2'
		Traceback (most recent call last):
		  File "<stdin>", line 1, in <module>
		TypeError: 'tuple' object does not support item assignment
		>>> x[1][1] = 'x'
		>>> x
		(1, ['a', 'x'], 3)
		>>>

Programming Python
==================

files
-----


打开文件时如果用'w'标志，那么如果文件存在的话会删除里面的内容，小心。

write()和writeline()不会在写入的内容后面加'\n'，而print会。

为什么print('abc', end="\n")不能运行
为什么print('ab',)可以运行，而且结尾不会自动加'\n'

tips
----

os.getcwd()返回当前工作目录。sys.path的值则是可导入模块的目录组成的列表，
包括当前脚本所在的目录。如果在一个脚本中同时运行这两个函数，这两个值并
不相同，当调用脚本时的目录不同于脚本文件所在的目录时。

sys.exc_info()返回最近的异常。traceback模块也可以。

内置的type()可以检查一个对象的类型。

与操作系统相关的标准模块主要有两个，即sys和os，前者主要是与python解释器
相关的，后者则包括与操作系统的其他内容。

shelves模块提供了按索引来从文件中存取对象的功能。

glib.glob('=.c')函数会返回当前目录下所有与'=.c'匹配的文件

input()从标准输入读入一个字符串。

可以将一个打开的文件对象赋值给sys.stdin，以后所有的标准输入就会从这个文件中读取。

dict_obj.items()函数以一个类似于集合的形式返回对象中的元素

pprint模块可以以更美观的方式显示一个对象。

map在python3中成了一个生成器

sum是一个内建函数

pydoc builtins会显示所有内建的函数、变量等等等等

str是内建的一个模块
string是标准库中的一个模块

print函数会自动在行尾加一个'\n'。
python中是区分大小写的

repr()将一个对象转换成字符串
ord()将一个字符转换成相应的ascii值
chr()同上，作用相反

eval可以将字符串当作可执行代码对待，然后计算出结果
	eval("[1, 2, 3]") => [1, 2, 3]

pickle模块可以在在文件中存取原生态的数据
struct模块可以处理二进制数据

range(-5, 5) => [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]

print和str函数会优先选用对象的__str__方法。如果没有__str__方法，则会使
用__repr__方法。__repr__应该返回一个字符串，这个字符串可以作为可执行代
码去重建该对象。而repr函数则只使用__repr__方法。repr主要用户交互环境，
例如在python命令行中直接输入一个对象，则会调用它的__repr__方法。

dictionary在赋值时如果索引是字符串，可以不加引号，前面需要加dict，并且
圆括号需要变成括号，里面的冒号改成等于号。例如mydict =
dict{name='zhangsan', age=14}

zip(obj1, obj2……）返回一个zip对象，其中的每个子对象是一个元组，每个元
组由zip参数中的各个对象提供。例如zip([1, 2, 3] [4, 5, 6])={1: 4, 2: 5,
3: 6}

[x for x in ...]，式中的第一个x也可以是一个表达式，例如下面的x就是一个
列表，而且里面还可以包含if和else等等。

[(rec['age'] == 2 if rec['age'] >= 45 else rec['age']) for rec in people]

盲点
====

生成器、迭代器
--------------

可迭代对象、迭代工具、迭代环境、迭代协议

生成器是实现迭代器的一种简便的方法。

生成器：生成器实际上就是一个普通的函数，这个函数返回一个迭代器。这种函
数不使用return语句返回值，而是使用一个yield语句返回值，而且在每返回一个
值后这个函数就会暂停，直到使用返回的迭代器的__next__()方法重新调用时，
这个函数又会接着从刚才暂停的地方继续运行，然后用yield返回一个值后再次暂
停。

for i in obj: ;
=> iter(obj)
=> __iter__(obj) == obj.__iter__()

迭代器的工作原理：

在一个迭代环境下，

第一步：迭代工具（例如for）在内部运行时会把可迭代对象传递给内置的
iter()函数，即iter(obj)，而iter()函数内部运行时又会调用__iter__()函数，
即__iter__(obj)。

第二步：可以分为两种情况：

第一种情况：这个函数在内部会调用返回一个迭代器，接着会调用这个迭代器的
next方法，并且捕捉StopInteration异常来 确定何时停止迭代。（为什么只能定
义next()方法，而定义__next__()不行）

.. class myclass_1:
..     def __init__(self, start, stop):
..         self.start = start - 1
..         self.stop = stop
..     def __iter__(self):
..         return self
..     def next(self):
..         if self.start == self.stop:
..             raise StopIteration
..         self.start += 1
..         return self.start = 2

.. for element in myclass_1(1, 5):
..     print(element)
.. print('')

第二种情况：将__iter__()函数本身写成一个生成器，__iter__()每次用yield返
回一个值并暂停，当迭代协议自动调用返回的生成器的__next__()方法
时，__iter__()又会从刚才暂停的地方继续执行。

class myclass_2:
    def __init__(self, start, stop):
        self.start = start - 1
        self.stop = stop
    def __iter__(self):
        while self.start < self.stop:
            self.start += 1
            yield self.start = 2

for element in myclass_2(1, 5):
    print(element)


帮助系统
========

__doc__
-------

dir(str) == dir('')			内置类型
dir(list) == dir([])
dir(hash) == dir({})

dir(sys)					模块的变量和函数列表
print(sys.__doc__)			模块格式化过后的
print(sys.stdin.__doc__)	模块里的变量
print(sys.exit.__doc__)		模块里的函数

help()
------


help命令以man方式全屏显示帮助信息。

help(ord)					内置函数

help(str)					内置类型的全部文档
help(str.encode)			内置类型的函数

一些小技巧
==========

- 字符串和列表的相互转换

	::

		>>> s = 'abc'
		>>> s[:]
		'abc'
		>>> mylist = list(s)
		>>> mylist
		['a', 'b', 'c']
		>>> ''.join(mylist)
		'abc'
		>>>
