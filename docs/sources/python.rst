================
 python学习笔记
================

.. contents::

Learning Python
===============

帮助系统
--------

- dir()

- __doc__

  ::

    dir(str) == dir('')
    dir(list) == dir([])
    dir(hash) == dir({})

    dir(sys)                    模块的变量和函数列表
    print(sys.__doc__)          模块格式化过后的
    print(sys.stdin.__doc__)    模块里的变量
    print(sys.exit.__doc__)     模块里的函数


- help()

  是交互模式下获取帮助信息的工具，以类似man方式全屏显示帮助信息。

  ::

    help(open)                  内置函数
    help(str)                   内置类型的全部文档
    help(str.encode)            内置类型的函数

- pydoc

  和交互界面下的help()显示的内容是一模一样的。


类型
----

变量的通用说明
~~~~~~~~~~~~~~

- 变量类型

  - 在某一时刻，python中的变量只是对一个对象的引用，变量本身的类型是可
    以随时改变的，即引用一个不同类型的对象。

  - 类型是与对象相关联的，而不是变量。

  - 每个对象有2个重要的头部信息：类型和引用计数器。

  - type()会返回一个对象的类型

    ::

      >>> type(1)
      <type 'int'>
      >>> type('abc')
      <type 'str'>
      >>> type([])
      <type 'list'>
      >>>

- 共享引用和原地修改

  ::

    >>> L1 = [2, 3, 4]
    >>> L2 = L1
    >>> L3 = L1[:]
    >>> L1[0] = 5
    >>> L1
    [5, 3, 4]
    >>> L2
    [5, 3, 4]
    >>> L3
    [2, 3, 4]

  L1和L2引用同一对象，而L3则是L1的复制。

  在标准库中的copy模块有复制任一对象的功能。

- 两种相等比较

  is 和 ==

  如果2个变量引用同一对象的话则是is，如果仅仅是这2个变量的值相等，但是
  不引用同一对象，那么它们只是==而不是is。

  ::

    >>> a = 'xy'
    >>> b = 'xy'
    >>> a == b, a is b
    (True, True)
    >>> c = 'x y'
    >>> d = 'x y'
    >>> c == d, c is d
    (True, False)
    >>>

  这是因为在内部，'xy'被缓存了，而'x y'则没有。

  另外，sys模块的getrefcount会返回一个对象被引用的次数。

  ::

    >>> import sys
    >>> sys.getrefcount(1)
    353
    >>> sys.getrefcount('a')
    11

- 真与假

  - 空的对象被认为是False，非空对象被认为是真。

  - 特殊对象None总被认为是假。

数字
~~~~

- repr,str和print

  默认的打印方式(即不使用print)内部是使用repr，如果使用print打印的话
  则是使用str。

  ::

    >>> num = 1 / 3.0
    >>> num
    0.3333333333333333
    >>> repr(num)
    '0.3333333333333333'
    >>> str(num)
    '0.333333333333'
    >>> print(num)
    0.333333333333

- 数字和字符串之间的相互转换

  - oct,hex将数字转换为相应进制的字符串

  - str将数字按十进制转换为相应进制的字符串

  - int()将字符串按照指定格式转换为数字，

  - eval计算表达式(是一个字符串)，相当于将字符串转换为数字

  - 格式化表达式"%"可以将数字转换为字符串

  ::

    >>> oct(19),hex(255)
    ('023', '0xff')
    >>> str(123)
    '123'
    >>> int('0100'),int('023',8),int('0xff',16)
    (100, 19, 255)
    >>> eval('100'),eval('0100'),eval('0x40')
    (100, 64, 64)
    >>> "%o %x %X" % (64,255,255)
    '100 ff FF'

- 浮点数运算时会出现精度问题，可以使用小数模块代替Decimal

- 布尔类型

  True,False。实际上是int类型的一个子集，不过重载了repr和print方法，
  打印时显示为True和False


字符串
~~~~~~

- python中没有单个的字符类型，只有字符串类型。

- python中的单引号和双引号可以互换，即使字符串中包含有转义字符。

  ::

    >>> print("a\nb\tc")
    a
    b   c
    >>> print('a\nb\tc')
    a
    b   c

- python中的三重引号并不会禁止其内部的转义字符

  ::

    >>> x = """abc
    ... def
    ... xxx\n\n
    ... yyy
    ... """
    >>> print(x)
    abc
    def
    xxx


    yyy

    >>>

- 转义:
  '\ooo' 八进制表示
  '\xhh' 十六进制表示

- 可以用r('...')来禁止转义

- unicode字符

  + 长度

    ::

      >>> len('中国')
      6
      >>> len(u'中国')
      2
      >>>

  + 和普通字符串的转换

    ::

      >>> str(u'abc')
      'abc'
      >>> unicode('abc')
      u'abc'
      >>>

- 索引和切片

  ::

    >>> s = 'abcdef'
    >>> s[1:3]
    'bc'
    >>> s[-1]
    'f'
    >>> s[::2]
    'ace'
    >>> s[5:1:-1]
    'fedc'
    >>>

- 字符的代码转换

  ::

    >>> ord('s')
    115
    >>> chr(115)
    's'
    >>>

- 基于字典的字符串格式化

  使用'%(key)t'这种格式，其中的"key"是dict的键，其中的't'表示格式化所
  用的格式

  另外，vars()函数会返回本函数调用时所有的变量和它的值组成的一个dict，
  可以和格式化字符串联合起来使用这个技巧

  >>> d = {'name': 'bob', 'age': 16}
  >>> "My name is %(name)s, my age is %(age)d" % d
  'My name is bob, my age is 16'
  >>>
  >>> food = 'bread'
  >>> drink = 'milk'
  >>> vars()
  {'d': {'age': 16, 'name': 'bob'}, '__builtins__': <module '__builtin__' (built-in)>, 'drink': 'milk', '__package__': None, 'food': 'bread', 's': 'abcdef', 'x': 'abc\ndef\nxxx\n\n\nyyy\n', '__name__': '__main__', '__doc__': None}
  >>> "%(food)s %(drink)s" % vars()
  'bread milk'
  >>>

字典
~~~~

- 构造字典的其它技术

  1.
    >>> dict(name='bob', age=18)
    {'age': 18, 'name': 'bob'}
  #.
    >>> dict([('name', 'bob'), ('age', 18)])
    {'age': 18, 'name': 'bob'}

    这种方法经常和zip()一起连用
  #.
    >>> dict.fromkeys(['a', 'b', 'c'], 0)
    {'a': 0, 'c': 0, 'b': 0}
    >>>

- 字典的一些方法

  d.keys(), d.values(), d.items()

- 字典的键并不一定总是字符串，也可以是数字等

元组
~~~~

- 只有一个元素的元组

  ::

    >>> a = (30)
    >>> a
    30
    >>> b = (40,)
    >>> b
    (40,)
    >>>

  与只有一个元素的列表相比较

  ::

    >>> x = [1]
    >>> x
    [1]
    >>> y = [2, ]
    >>> y
    [2]

- 元组的圆括号有时可以省略，但最好不省略以增强可读性

- 元组的不可变性是指元组本身及其顶层内容，而不是元组中嵌套的值

  ::

    >>> x = (1, ['a', 'b'], 3)
    >>> x[1] = '2'
    Traceback (most recent call last):
          File "<stdin>", line 1, in <module>
    TypeError: 'tuple' object does not support item assignment
    >>> x[1][1] = 'x'
    >>> x
    (1, ['a', 'x'], 3)
    >>>

语句
----

简介
~~~~

- python中唯一需要分号的地方就是在一行里同时写几个语句的时候。

- 如果一条一句需要分成几行写的话，可以在这条语句前后加上括号。

  ::

    if (A == 1 and
        B == 1 and
        C == 1):
            print('...')

- 有用的函数raw_input('prompt:')，从标准输入读取输入并转化为字符串返回。

赋值语句
~~~~~~~~

- 第一种具有特色的赋值操作:序列赋值语句

  ::

    >>> a, b = 1, 2
    >>> a
    1
    >>> b
    2
    >>> x, y = (1, 2)
    >>> x
    1
    >>> y
    2
    >>> [m, n] = [3, 4]
    >>> m
    3
    >>> n
    4
    >>> [a, b] = (1, 2)
    >>> a, b
    (1, 2)
    >>> a, b, c ,d = 'spam'
    >>> a
    's'
    >>> b
    'p'
    >>> c
    'a'
    >>> d
    'm'
    >>>

  可以利用这种赋值方法衍生出一个小技巧：互换两个变量的值

  ::

    >>> a, b = 1, 2
    >>> a, b
    (1, 2)
    >>> a, b = b, a
    >>> a, b
    (2, 1)
    >>>
- 第二种具有特色的赋值操作:多目标赋值

  ::

    >>> a = b = 1
    >>> a, b
    (1, 1)
    >>> a = 2
    >>> a, b
    (2, 1)
    >>>

  这种方法对于常数赋值没问题，但是对于共享引用的赋值则会出现问题，要多加小心

  ::

    >>> c = d = []
    >>> c, d
    ([], [])
    >>> c.append(1)
    >>> c, d
    ([1], [1])
    >>>

- 第三种具有特色的赋值操作:增强赋值

  即 a += 2 这种格式。

  注意增强赋值是原地修改，对于共享引用来说a += b和a = a + b的作用是不同
  的。请看下面两种情况的不同。

  ::

    >>> L = [1, 2]
    >>> M = L
    >>> L = L + [3, 4]
    >>> L
    [1, 2, 3, 4]
    >>> M
    [1, 2]
    >>>

  ::

    >>> L = [1, 2]
    >>> M = L
    >>> L += [3, 4]
    >>> L
    [1, 2, 3, 4]
    >>> M
    [1, 2, 3, 4]
    >>>

控制结构
~~~~~~~~

- python中有范围测试操作符

  ::

    >>> a = 2
    >>> 1 < a < 3
    True
    >>>
    >>> f = lambda a, b: a if a < b else b
    >>> f(3, 2)
    2
    >>>     

- 后置的if语句只有在列表解析里或者lambda的主体表达式里才能使用

  ::

    >>> a = 3
    >>> print(a) if a > 0
      File "<stdin>", line 1
        print(a) if a > 0
                        ^
    SyntaxError: invalid syntax
    >>>
    >>> mystr = 'abc'
    >>> [ ch for ch in mystr ]
    ['a', 'b', 'c']
    >>> [ ch for ch in mystr if ch > 'a' ]
    ['b', 'c']
    >>>

- and和or的返回值

  ::

    >>> 2 or 3
    2
    >>> [] or 3
    3
    >>> [] or ()
    ()
    >>> 2 and 3
    3
    >>> 2 and []
    []
    >>> [] and ()
    []
    >>>

- while和for结构都有一个可选的else语句

  ::

    >>> a = 3
    >>> while a > 0:
    ...   print(a)
    ...   a -= 1
    ... else:
    ...   print(a)
    ...
    3
    2
    1
    0
    >>> for x in range(1, 3):
    ...   print(x)
    ... else:
    ...   print(x)
    ...
    1
    2
    2
    >>>

- 可以在for中进行元组赋值

  ::

    >>> T = [(1, 2), (3, 4), (5, 6)]
    >>> for (a, b) in T:
    ...   print(a, b)
    ...
    (1, 2)
    (3, 4)
    (5, 6)
    >>>

- range()

  ::

    >>> range(5)
    [0, 1, 2, 3, 4]
    >>> range(1, 3)
    [1, 2]
    >>> range(1, 10, 2)
    [1, 3, 5, 7, 9]
    >>> range(-5, 5, 2)
    [-5, -3, -1, 1, 3]
    >>>

- zip()

  zip()的参数为一个或多个序列，返回值为一个由一系列元组组成的列表，其中的
  每个元组包含了zip()参数中每个序列的一个元素。

  ::

    >>> L1 = ['a', 'b', 'c']
    >>> L2 = [1, 2, 3]
    >>> L3 = ['x', 'y', 'z']
    >>> zip(L1, L2, L3)
    [('a', 1, 'x'), ('b', 2, 'y'), ('c', 3, 'z')]
    >>>

  应用场合:

  - 和for结合使用实现并行迭代

    ::

      >>> L1 = [1, 2, 3]
      >>> L2 = [4, 5, 6]
      >>> for (a, b) in zip(L1, L2):
      ...   print('%d + %d = %d' % (a, b, a + b))
      ...
      1 + 4 = 5
      2 + 5 = 7
      3 + 6 = 9
      >>>

  - 构造字典

    ::

      >>> keys = ['a', 'b', 'c']
      >>> vals = [1, 2, 3]
      >>> D = dict(zip(keys, vals))
      >>> D
      {'a': 1, 'c': 3, 'b': 2}
      >>>

- enumerate()

  返回一个对象生成器对象，对其进行迭代时每次会返回(index, value)元组

  ::

    >>> a = 'spam'
    >>> for (index, value) in enumerate(a):
    ...   print(index, value)
    ...
    (0, 's')
    (1, 'p')
    (2, 'a')
    (3, 'm')
    >>>


函数
----

函数概述
~~~~~~~~

- def语句是一个可执行语句，它创建一个函数对象并将其赋值给一个变量名(即
  函数名)。

- 一个没有返回值的函数实际上是返回了一个none对象。

作用域
~~~~~~

python中变量名的搜索过程：

1. l(local,函数内)
#. E(嵌套作用域，即上层函数）
#. G(global,全局)
#. B(builtin,内置)

内置变量或者函数是由__builtin__内置模块提供的。默认情况下是不会自动执
行"import __builtin__"语句的，但由于python中变量名的搜索过程最后会搜
索内置模块，所以会搜索到内置的函数等。另一方面这也解释了为什么自定义
一个和内置函数同名的变量名会覆盖内置函数。

global声明

当在一个函数定义中给一个外部变量赋值的时候，才有必要用global将其声明
为全局变量。如果只是使用一个全局变量的值，则没有必要也不能用global将
其声明为全局变量。

参数
~~~~

python中函数的参数的实现：是将对象的引用赋值给参数进行传递。和python
中的变量赋值是一样的。

::

  >>> def myfun(myval):
  ...   myval[0] = 'a'
  ...
  >>> L = ['x', 'y']
  >>> myfun(L)
  >>> L
  ['a', 'y']
  >>>

特殊形式的参数设定和调用方式：

- 函数调用：位置参数

  即调用一个函数时通过指定行参名称进行赋值，而不是按照从左到右的顺序进行赋值。

  ::

    >>> def myfun(a, b):
    ...   print(a, b)
    ...
    >>> def myfun(a, b, c):
    ...   print(a, b, c)
    ...
    >>> myfun(b = 3, c = 5, a = 2)
    (2, 3, 5)
    >>>

- 函数定义：默认参数

  即在定义时为参数提供默认值。

  注意"默认参数"和"位置参数"的区别：虽然看起来很像，但是，默认参数是在
  函数定义时提供默认值，而位置参数则是在调用函数时指定赋值给哪个参数。

  ::

    >>> def myfun(a, b, c=10):
    ...   print(a, b, c)
    ...
    >>> myfun(1, 2)
    (1, 2, 10)
    >>>

- 函数定义：搜集参数形成列表

  ::

    >>> def myfun(*myargs):
    ...   print(myargs)
    ...
    >>> myfun(1, 2, 3)
    (1, 2, 3)
    >>>

- 函数定义：搜集参数形成字典

  ::

    >>> def myfun(**myargs):
    ...   print(myargs)
    ...
    >>> myfun(x=1, y=2)
    {'y': 2, 'x': 1}
    >>>

- 函数调用：分解列表

  ::

    >>> def myfun(a, b, c):
    ...   print(a, b, c)
    ...
    >>> L = [1, 2, 3]
    >>> myfun(*L)
    (1, 2, 3)
    >>>

- 函数调用：分解字典

  ::

    >>> def myfun(a, b, c):
    ...   print(a, b, c)
    ...
    >>> D1 = {'a': 1, 'b': 2, 'c': 3}
    >>> myfun(**D1)
    (1, 2, 3)
    >>> D2 = {'x': 1, 'y': 2, 'z': 3}
    >>> myfun(**D2)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: myfun() got an unexpected keyword argument 'y'
    >>>

  由此可以看出调用函数时如果用'**'分解一个字典，则字典的key必须和这个函
  数定义时的行参名字一一对应，这就对这种方式的应用形成了很大的限制。

- 将函数名作为参数

::

  >>> def calc(myfun, a, b):
  ...   print(myfun(a, b))
  ...
  >>> def myadd(x, y):
  ...   return(x + y)
  ...
  >>> def mysub(x, y):
  ...   return(x - y)
  ...
  >>> calc(myadd, 3, 1)
  4
  >>> calc(mysub, 3, 1)
  2
  >>>

lambda表达式
~~~~~~~~~~~~

lambda是一个表达式而不是一个语句，这样就使它可以出现在def语句不能出现的
地方，例如列表常量中或者函数调用中。

lambda的主体是一个简单的表达式，而不能是一个代码块。

lambda的主体表达式中不可以有if语句，但可以包含后置的if ...else ..语句；
不可以有for和while语句，但也可以用map或者列表解析来实现同样的循环目的。

::

  >>> a = 2
  >>> 1 < a < 3
  True
  >>>
  >>> f = lambda a, b: a if a < b else b
  >>> f(3, 2)
  2
  >>>     

::

  >>> L = lambda mylist: [ sys.stdout.write(tmp + '\n') for tmp in mylist ]
  >>> L(['abc', 'xxx', 'yyy'])
  abc
  xxx
  yyy
  [None, None, None]
  >>>
  >>> L = lambda x: map(sys.stdout.write, x)
  >>> L(['xxx\n', 'yyy\n'])
  xxx
  yyy
  [None, None]
  >>> 
  
在lambda表达式里不能使用print，而要使用sys.stdout.write("...")表达式。
因为python 2中print是一个语句，而语句必须单独成行。python3的lambda里就
可以使用print()了，因为print成了一个函数。

应用

  - 跳转表

    ::

      >>> L = [lambda x: x + x, lambda x: x * x, lambda x: x ** x]
      >>> for x in L:
      ...   print(x(3))
      ... 
      6
      9
      27
      >>>   

  - 回调
  
一些方便的函数
~~~~~~~~~~~~~~

- apply()

- map()

- filter()

- reduce()


模块和类
--------

- import和from是赋值语句

- 由导入而建立的模块的命名空间是字典，可以用dir(M)或者M.__dict__.keys()取得

- M.__file__会指明M模块来自于哪个文件

- reload()与import和from的不同：

  - reload()是内置函数，而import和from则是语句
  - reload()只有在import和from成功后才能使用

- _X和__all__

  用from *导入一个模块的时候，会先检测 __all__ 这个列表，如果它不为空的话，
  则只导入其中列出的变量，如果它为空，则导入所有变量，除了以_开头的。

  利用这个方法可以将模块中的一些数据隐藏，防止其被导入。(使用import导入
  时则没有任何办法隐藏)
  
  ::

    LearningPython/ch21 $ cat mymodule_1.py
    #!/bin/env python
    # -*- coding: utf-8 -*-

    __all__ = ['a']

    a = 1
    b = [2, 3]
    LearningPython/ch21 $ cat test1.py
    #!/bin/env python
    # -*- coding: utf-8 -*-

    from mymodule_1 import *

    print(a)
    print(b)
    LearningPython/ch21 $ python test1.py
    1
    Traceback (most recent call last):
      File "test1.py", line 7, in <module>
        print(b)
    NameError: name 'b' is not defined

  ::    

    LearningPython/ch21 $ cat mymodule_2.py
    #!/bin/env python
    # -*- coding: utf-8 -*-

    c = 7
    _d = [4, 5]
    LearningPython/ch21 $ cat test2.py
    #!/bin/env python
    # -*- coding: utf-8 -*-

    from mymodule_2 import *

    print(c)
    print(_d)
    LearningPython/ch21 $ python test2.py
    7
    Traceback (most recent call last):
      File "test2.py", line 7, in <module>
        print(_d)
    NameError: name '_d' is not defined
    LearningPython/ch21 $ 

- __name__和__main__

  每个文件都有一个__name__变量名，当这个文件作为模块导入时，__name__就
  会被自动赋值为模块名，当这个文件作为一个顶层程序运行时，它会自动设置
  为字符串'__main__'。

- sys.path是模括搜索目录组成的列表，可以修改

- import...as...

- 模块的相对导入和绝对导入

    import module

      会按照sys.path列表中指定位置搜索并导入模块

    import .module

      会导入当前文件目录下的模块

    import ..module

      会导入当前文件目录的父目录下的模块

一些小技巧
==========

- 字符串和列表的相互转换

  ::

    >>> s = 'abc'
    >>> s[:]
    'abc'
    >>> mylist = list(s)
    >>> mylist
    ['a', 'b', 'c']
    >>> ''.join(mylist)
    'abc'
    >>>

Programming Python
==================

files
-----


打开文件时如果用'w'标志，那么如果文件存在的话会删除里面的内容，小心。

write()和writeline()不会在写入的内容后面加'\n'，而print会。

为什么print('abc', end="\n")不能运行
为什么print('ab',)可以运行，而且结尾不会自动加'\n'

tips
----

os.getcwd()返回当前工作目录。sys.path的值则是可导入模块的目录组成的列表，
包括当前脚本所在的目录。如果在一个脚本中同时运行这两个函数，这两个值并
不相同，当调用脚本时的目录不同于脚本文件所在的目录时。

sys.exc_info()返回最近的异常。traceback模块也可以。

内置的type()可以检查一个对象的类型。

与操作系统相关的标准模块主要有两个，即sys和os，前者主要是与python解释器
相关的，后者则包括与操作系统的其他内容。

shelves模块提供了按索引来从文件中存取对象的功能。

glib.glob('=.c')函数会返回当前目录下所有与'=.c'匹配的文件

input()从标准输入读入一个字符串。

可以将一个打开的文件对象赋值给sys.stdin，以后所有的标准输入就会从这个文件中读取。

dict_obj.items()函数以一个类似于集合的形式返回对象中的元素

pprint模块可以以更美观的方式显示一个对象。

map在python3中成了一个生成器

sum是一个内建函数

pydoc builtins会显示所有内建的函数、变量等等等等

str是内建的一个模块
string是标准库中的一个模块

print函数会自动在行尾加一个'\n'。
python中是区分大小写的

repr()将一个对象转换成字符串
ord()将一个字符转换成相应的ascii值
chr()同上，作用相反

eval可以将字符串当作可执行代码对待，然后计算出结果
    eval("[1, 2, 3]") => [1, 2, 3]

pickle模块可以在在文件中存取原生态的数据
struct模块可以处理二进制数据

range(-5, 5) => [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]

print和str函数会优先选用对象的__str__方法。如果没有__str__方法，则会使
用__repr__方法。__repr__应该返回一个字符串，这个字符串可以作为可执行代
码去重建该对象。而repr函数则只使用__repr__方法。repr主要用户交互环境，
例如在python命令行中直接输入一个对象，则会调用它的__repr__方法。

dictionary在赋值时如果索引是字符串，可以不加引号，前面需要加dict，并且
圆括号需要变成括号，里面的冒号改成等于号。例如mydict =
dict{name='zhangsan', age=14}

zip(obj1, obj2……）返回一个zip对象，其中的每个子对象是一个元组，每个元
组由zip参数中的各个对象提供。例如zip([1, 2, 3] [4, 5, 6])={1: 4, 2: 5,
3: 6}

[x for x in ...]，式中的第一个x也可以是一个表达式，例如下面的x就是一个
列表，而且里面还可以包含if和else等等。

[(rec['age'] == 2 if rec['age'] >= 45 else rec['age']) for rec in people]

专题
====

生成器、迭代器
--------------

可迭代对象、迭代工具、迭代环境、迭代协议

生成器是实现迭代器的一种简便的方法。

生成器：生成器实际上就是一个普通的函数，这个函数返回一个迭代器。这种函
数不使用return语句返回值，而是使用一个yield语句返回值，而且在每返回一个
值后这个函数就会暂停，直到使用返回的迭代器的__next__()方法重新调用时，
这个函数又会接着从刚才暂停的地方继续运行，然后用yield返回一个值后再次暂
停。

::

  for i in obj: ;
  => iter(obj)
  => __iter__(obj) == obj.__iter__()

迭代器的工作原理：

在一个迭代环境下，

第一步：迭代工具（例如for）在内部运行时会把可迭代对象传递给内置的
iter()函数，即iter(obj)，而iter()函数内部运行时又会调用__iter__()函数，
即__iter__(obj)。

第二步：可以分为两种情况：

第一种情况：这个函数在内部会调用返回一个迭代器，接着会调用这个迭代器的
next方法，并且捕捉StopInteration异常来 确定何时停止迭代。（为什么只能定
义next()方法，而定义__next__()不行）

::

  class myclass_1:
      def __init__(self, start, stop):
          self.start = start - 1
          self.stop = stop
      def __iter__(self):
          return self
      def next(self):
          if self.start == self.stop:
              raise StopIteration
          self.start += 1
          return self.start = 2

  for element in myclass_1(1, 5):
      print(element)
  print('')

第二种情况：将__iter__()函数本身写成一个生成器，__iter__()每次用yield返
回一个值并暂停，当迭代协议自动调用返回的生成器的__next__()方法
时，__iter__()又会从刚才暂停的地方继续执行。

::

  class myclass_2:
      def __init__(self, start, stop):
          self.start = start - 1
          self.stop = stop
      def __iter__(self):
          while self.start < self.stop:
              self.start += 1
              yield self.start = 2

  for element in myclass_2(1, 5):
      print(element)
