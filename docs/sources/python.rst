====================
python学习笔记
====================

.. contents::

Learning Python
===============

动态变量类型
------------

变量类型
........

- 在某一时刻，python中的变量只是对一个对象的引用，变量本身的类型是可以
  随时改变的，即引用一个不同类型的对象。

- 类型是与对象相关联的，而不是变量。

- 每个对象有2个重要的头部信息：类型和引用计数器。


共享引用和原地修改
..................

>>> L1 = [2, 3, 4]
>>> L2 = L1
>>> L3 = L1[:]
>>> L1[0] = 5
>>> L1
[5, 3, 4]
>>> L2
[5, 3, 4]
>>> L3
[2, 3, 4]

L1和L2引用同一对象，而L3则是L1的复制。

在标准库中的copy模块有复制任一对象的功能。

两种相等比较
............

is 和 ==

如果2个变量引用同一对象的话则是is，如果仅仅是这2个变量的值相等，但是不
引用同一对象，那么它们只是==而不是is。

sys模块的getrefcount会返回一个对象被引用的次数。

>>> import sys
>>> sys.getrefcount(1)
353
>>> sys.getrefcount('a')
11

数字
--------------------

repr,str和print
....................

>>> num = 1 / 3.0
>>> num
0.3333333333333333
>>> repr(num)
'0.3333333333333333'
>>> str(num)
'0.333333333333'
>>> print(num)
0.333333333333

默认的打印方式(即不使用print)内部是使用repr，如果使用print打印的话则是
使用str。

数字和字符串之间的相互转换
..............................

>>> oct(19),hex(255)
('023', '0xff')
>>> int('0100'),int('023',8),int('0xff',16)
(100, 19, 255)
>>> eval('100'),eval('0100'),eval('0x40')
(100, 64, 64)
>>> "%o %x %X" % (64,255,255)
'100 ff FF'

oct,hex将数字转换为相应进制的字符串

int()将字符串按照指定格式转换为数字，

eval计算表达式(是一个字符串)，相当于将字符串转换为数字

格式化表达式"%"可以将数字转换为字符串

浮点数运算时会出现精度问题，可以使用小数模块代替Decimal

布尔类型
....................

True,False

实际上是int类型的一个子集，不过重载了repr和print方法，打印时显示为True和False


字符串
--------------------

python中没有单个的字符类型，只有字符串类型。

python中的单引号和双引号可以互换，即使字符串中包含有转义字符。

>>> print("a\nb\tc")
a
b	c
>>> print('a\nb\tc')
a
b	c



列表
----


字典
----

元组
----


Programming Python
==================

files
-----


打开文件时如果用'w'标志，那么如果文件存在的话会删除里面的内容，小心。

write()和writeline()不会在写入的内容后面加'\n'，而print会。

为什么print('abc', end="\n")不能运行
为什么print('ab',)可以运行，而且结尾不会自动加'\n'

tips
----

os.getcwd()返回当前工作目录。sys.path的值则是可导入模块的目录组成的列表，
包括当前脚本所在的目录。如果在一个脚本中同时运行这两个函数，这两个值并
不相同，当调用脚本时的目录不同于脚本文件所在的目录时。

sys.exc_info()返回最近的异常。traceback模块也可以。

内置的type()可以检查一个对象的类型。

与操作系统相关的标准模块主要有两个，即sys和os，前者主要是与python解释器
相关的，后者则包括与操作系统的其他内容。

shelves模块提供了按索引来从文件中存取对象的功能。

glib.glob('=.c')函数会返回当前目录下所有与'=.c'匹配的文件

input()从标准输入读入一个字符串。

可以将一个打开的文件对象赋值给sys.stdin，以后所有的标准输入就会从这个文件中读取。

dict_obj.items()函数以一个类似于集合的形式返回对象中的元素

pprint模块可以以更美观的方式显示一个对象。

map在python3中成了一个生成器

sum是一个内建函数

pydoc builtins会显示所有内建的函数、变量等等等等

str是内建的一个模块
string是标准库中的一个模块

print函数会自动在行尾加一个'\n'。
python中是区分大小写的

repr()将一个对象转换成字符串
ord()将一个字符转换成相应的ascii值
chr()同上，作用相反

eval可以将字符串当作可执行代码对待，然后计算出结果
	eval("[1, 2, 3]") => [1, 2, 3]

pickle模块可以在在文件中存取原生态的数据
struct模块可以处理二进制数据

range(-5, 5) => [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]

print和str函数会优先选用对象的__str__方法。如果没有__str__方法，则会使
用__repr__方法。__repr__应该返回一个字符串，这个字符串可以作为可执行代
码去重建该对象。而repr函数则只使用__repr__方法。repr主要用户交互环境，
例如在python命令行中直接输入一个对象，则会调用它的__repr__方法。

dictionary在赋值时如果索引是字符串，可以不加引号，前面需要加dict，并且
圆括号需要变成括号，里面的冒号改成等于号。例如mydict =
dict{name='zhangsan', age=14}

zip(obj1, obj2……）返回一个zip对象，其中的每个子对象是一个元组，每个元
组由zip参数中的各个对象提供。例如zip([1, 2, 3] [4, 5, 6])={1: 4, 2: 5,
3: 6}

[x for x in ...]，式中的第一个x也可以是一个表达式，例如下面的x就是一个
列表，而且里面还可以包含if和else等等。

[(rec['age'] == 2 if rec['age'] >= 45 else rec['age']) for rec in people]

盲点
====

生成器、迭代器
--------------

可迭代对象、迭代工具、迭代环境、迭代协议

生成器是实现迭代器的一种简便的方法。

生成器：生成器实际上就是一个普通的函数，这个函数返回一个迭代器。这种函
数不使用return语句返回值，而是使用一个yield语句返回值，而且在每返回一个
值后这个函数就会暂停，直到使用返回的迭代器的__next__()方法重新调用时，
这个函数又会接着从刚才暂停的地方继续运行，然后用yield返回一个值后再次暂
停。

for i in obj: ;
=> iter(obj)
=> __iter__(obj) == obj.__iter__()

迭代器的工作原理：

在一个迭代环境下，

第一步：迭代工具（例如for）在内部运行时会把可迭代对象传递给内置的
iter()函数，即iter(obj)，而iter()函数内部运行时又会调用__iter__()函数，
即__iter__(obj)。

第二步：可以分为两种情况：

第一种情况：这个函数在内部会调用返回一个迭代器，接着会调用这个迭代器的
next方法，并且捕捉StopInteration异常来 确定何时停止迭代。（为什么只能定
义next()方法，而定义__next__()不行）

.. class myclass_1:
..     def __init__(self, start, stop):
..         self.start = start - 1
..         self.stop = stop
..     def __iter__(self):
..         return self
..     def next(self):
..         if self.start == self.stop:
..             raise StopIteration
..         self.start += 1
..         return self.start = 2

.. for element in myclass_1(1, 5):
..     print(element)
.. print('')

第二种情况：将__iter__()函数本身写成一个生成器，__iter__()每次用yield返
回一个值并暂停，当迭代协议自动调用返回的生成器的__next__()方法
时，__iter__()又会从刚才暂停的地方继续执行。

class myclass_2:
    def __init__(self, start, stop):
        self.start = start - 1
        self.stop = stop
    def __iter__(self):
        while self.start < self.stop:
            self.start += 1
            yield self.start = 2

for element in myclass_2(1, 5):
    print(element)


帮助系统
========

__doc__
-------

dir(str) == dir('')			内置类型
dir(list) == dir([])
dir(hash) == dir({})

dir(sys)					模块的变量和函数列表
print(sys.__doc__)			模块格式化过后的
print(sys.stdin.__doc__)	模块里的变量
print(sys.exit.__doc__)		模块里的函数

help()
------


help命令以man方式全屏显示帮助信息。

help(ord)					内置函数

help(str)					内置类型的全部文档
help(str.encode)			内置类型的函数
