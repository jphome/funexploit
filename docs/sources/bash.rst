============
Bash学习笔记
============

.. contents::

shell执行命令的过程
===================

下面是当shell读取一行命令后所采取的动作的一个简要的描述。

  1、从一个文件中读取输入、或者从由-c选项指定的字符串读取、或者从用户终端
  读取。

  2、按照引用规则将输入内容分割成词和操作符。这些标记用 metacharacters 分割。
  别名的扩展也是在这一步。

  3、将这些标记分割成简单的和复合的命令。

  4、执行各种shell扩展，将扩展后的标记形成文件名列表、命令和参数。

  5、如果必要的话，执行重定向、从参数列表中移除重定向操作符及其操作数。

  6、执行命令。

  7、等待命令执行完毕，收集其退出状态码。这一步是可选的。

引用
====

- 转义字符

  一个没有引起来的反斜杠是Bash的转义字符。它会转义紧接着的下一个字符，换行符除外。如果反斜杠后面跟着一个换行符，并且反斜杠没有引起来，那么反斜杠和它后面的换行符将会被看作“续行”（也就是说将它从输入流中移除）。

- 单引号

  用单引号将一些字符引起来，可以保持单引号内字符的字面意思。一个单引号不能在两个单引号内，用反斜杠作前导符也不起作用。

- 双引号

  用双引号将一些字符引起来可以保持双引号内字符的字面意思，除了$、'、\，以及在历史扩展机制起作用时的!在内。双引号内的$和'有其特殊含义。

shell命令形式
=============

- 管道

  管道有两种形式：即|和&|，后者表示将管道前的命令的标准错误输出也连接到管道后命令的标准输入，相当于2>&1|的简写形式p。

  一个管道中各个命令在各自的子shell中执行。

- 命令列表

  命令列表即一系列的命令的一个列表，可以用4种方式连接起来：;和&和&&和||。其中;和&的优先级相同，&&和||的优先级相同。

  + 由;连接的命令按顺序执行，返回状态为列表中最后一个命令。

  + 由&连接的命令同时异步执行，哪个命令先执行完是不可预测的，返回状态结果为0。

  + 由&&连接的命令执行时，只有&&之前的命令执行结果为TRUE时，&&后面的命令才会执行。返回状态为最后一个执行的命令的返回状态。

  + 由||连接的命令执行时，只有||FALSE时，||后面的命令才会执行。返回状态为最后一个执行的命令的返回状态。

  ::

    forfun@mygentoo ~ $ echo a; echo b; echo c; echo d
    a
    b
    c
    d
    forfun@mygentoo ~ $ echo a & echo b & echo c & echo d
    [1] 3177
    [2] 3178
    [3] 3179
    d
    forfun@mygentoo ~ $ b
    a
    c

    [1]   Done                    echo a
    [2]-  Done                    echo b
    [3]+  Done                    echo c
    forfun@mygentoo ~ $ echo a && echo b && ech c && echo d
    a
    b
    bash: ech: command not found
    forfun@mygentoo ~ $ ech a || echo b
    bash: ech: command not found
    b
    forfun@mygentoo ~ $


- 命令组合

  有两种形式：( LIST ) 和 { LIST; }。

  前者会创建一个子shell，命令列表会在这个子shell中执行，而后者则是在当前shell中执行。

  ::

    forfun@mygentoo ~ $ echo $BASH_SUBSHELL
    0
    forfun@mygentoo ~ $ ( echo a && echo $BASH_SUBSHELL )
    a
    1
    forfun@mygentoo ~ $ { echo a && echo $BASH_SUBSHELL; }
    a
    0
    forfun@mygentoo ~ $

coprocess
---------

...

parallet
--------

...

InvokingBash
============

BashStartupFiles（Bash启动文件）<EOF>
-------------------------------------

1、作为一个交互的登录shell或者非交互shell并且带--login选项调用时读取的文件：

    /etc/profile

然后再依次寻找以下文件，并执行第一个找到的文件：

    ~/.bash_profile
    ~/.bash_login
    ~/.profile

如果带--noprofile参数调用时则不会读取这些文件。

如果一个登录shell退出时会读取~/.bash_logout文件。

2、作为一个交互的非登录shell调用时，会读取~/.bashrc。


一般~/.bash_profile包含以下行：

::

  `if [ -f ~/.bashrc ]; then . ~/.bashrc; fi'

在我的系统上默认情况下没有~/.bash_profile和~/.bash_login文件，而
在~/.profile文件中包含以下行：

::

    # if running bash
    if [ -n "$BASH_VERSION" ]; then
        # include .bashrc if it exists
        if [ -f "$HOME/.bashrc" ]; then
        . "$HOME/.bashrc"
        fi
    fi

可以用--norc选项禁止读取这个文件，也可以用--rcfile选项来指定一个文件来
代替。

3、作为一个非交互shell登录时，读取环境变量BASH_ENV指定的文件。

如果带有--login参数调用一个非交互shell时会读取登录shell的启动文件。

4、用sh命令调用时<略>

5、用POSIX模式调用时<略>

6、被一个远程shell守护进程调用时<略>

7、Invoked with unequal effective and real UID/GIDs
